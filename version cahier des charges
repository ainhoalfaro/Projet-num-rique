import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

#MAILLAGE:
def maillage(h, N):
    maillage = []
    for i in range(N):
        maillage.append([])
        for j in range(N):
            maillage[i].append([])
            for k in range(N):
                maillage[i][j].append((i * h, j * h, k * h))
    return maillage

maillage_M = maillage(h, N)
maillage_P = maillage(h, N)
#NIVEAU 4
#creation de la fonction qui calcule la composante PM

def calcul_composantes_vect(M, position):
    # Calculer les composantes du vecteur PM
    PM = [M[i] - position[i] for i in range(3)]
    return PM


#NIVEAU 3
import numpy as np

def calcul_norme_vect(PM):
    # calculer la norme du vecteur PM
    somme = 0
    for i in PM:
        somme += i** 2
    norme_PM = np.sqrt(somme)
    return norme_PM


#NIVEAU 2
def calcul_potentiel(epsilon, norme_PM, charge):
    # Calcul du potentiel électrique au point M dû à la charge q
    V = charge / (4 * np.pi * epsilon * norme_PM)
    return V

def calcul_champ_electrique(epsilon, norme_PM, charge, PM):
    # Calculer les composantes du champ électrique
    E_components =[ (comp * charge) / ((norme_PM ** 3) * (4 * np.pi * epsilon) )for comp in PM]
    # On utilise np.array pour assembler les composantes du vecteur dans un tableau numpy
    E = np.array(E_components)
    return E

# Test des sous-fonctions avec un point simple
M = [2, 2, 2]
P = ([1, 1, 1], 1e-9)
position=P[0]
charge=P[1]
epsilon = 8.85e-12 
PM = calcul_composantes_vect(M, P[0])
norme_PM = calcul_norme_vect(PM)
print("Composantes de PM:", PM)
print("Norme de PM:", norme_PM)

# Test de la fonction pour calculer le champ électrique et le potentiel

potentiel = calcul_potentiel(epsilon, norme_PM, charge)
print("Potentiel électrique calculé au point M:", potentiel, "V")


champ_electrique = calcul_champ_electrique(epsilon, norme_PM, charge, PM)
print("Champ électrique calculé au point M:", champ_electrique, "N/C") 

N = 20 # maillage de dimension 20x20x20
h = 1

# Calculer le potentiel électrique et le champ électrique pour chaque point du maillage
potentiel_values = np.zeros((N, N, N))
champ_electrique_values = np.zeros((N, N, N, 3))

# Test et impression de la valeur du potentiel et du champ électrique à un point donné
test_point = [2,2,2]  # Coordonnées du point de test


for i in range(N):
    for j in range(N):
        for k in range(N):
            PM = calcul_composantes_vect(maillage_M[i][j][k], position)
            norme_PM = calcul_norme_vect(PM)
            potentiel_values[i, j, k] = calcul_potentiel(epsilon, norme_PM, charge)
            champ_electrique_values[i, j, k] = calcul_champ_electrique(epsilon, norme_PM, charge, PM)
            
            # Test et impression de la valeur du potentiel et du champ électrique au point de test
            if maillage_M[i][j][k] == test_point:
                print("Coordonnées du point de test :", test_point)
                print("Potentiel électrique au point de test :", potentiel_values[i, j, k])
                print("Champ électrique au point de test :", champ_electrique_values[i, j, k])
                print()

# Affichage des vecteurs du champ électrique
fig = plt.figure(figsize=(12, 9))
ax = fig.add_subplot(111, projection='3d')

for i in range(0,N,2):
    for j in range(0,N,2):
        for k in range(0,N,2):
            ax.quiver(maillage_M[i][j][k][0], maillage_M[i][j][k][1], maillage_M[i][j][k][2],
                      champ_electrique_values[i, j, k][0],
                      champ_electrique_values[i, j, k][1],
                      champ_electrique_values[i, j, k][2],
                      length=1, normalize=True, color='blue')
            


ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('Z')
ax.set_title('Champ électrique d\'un condensateur avec distribution de charge')

# Créer une grille pour les lignes équipotentielles
x = np.linspace(0, N-1, N)
y = np.linspace(0, N-1, N)
z = np.linspace(0, N-1, N)

X, Y, Z = np.meshgrid(x, y, z)

# Tracer les lignes équipotentielles
plt.figure(figsize=(12, 9))
plt.contour(X[:,:,0], Y[:,:,0], potentiel_values[:,:,0], 50, cmap='coolwarm')
plt.xlabel('X')
plt.ylabel('Y')
plt.title('Lignes équipotentielles d\'un point ponctuelle avec distribution de charge')
plt.colorbar(label='Potentiel électrique (V)')
plt.grid(True)
plt.show()


def distribution_plaqueinfinie (position, y, charge):
    x, y, z = position
    # Distribution de charge pour un condensateur avec des plaques parallèles chargées
    if y == yplaque: # Plaque positive
        return charge
    else:
        return 0.0  # Aucune charge ailleurs 

# Position de la plaque chargée
yplaque = 6

# Calcul des coordonnées du maillage P qui respectent la condition sur y==yfixe et leur charge associée
coordonnees_maillage_P = [(i * h, yplaque, k * h) for i in range(N) for k in range(N)]
charges_maillage_P = [distribution_plaqueinfinie(P, yplaque, P[1]) for P in coordonnees_maillage_P]


def distribution_doubleplaque (position, yplaque1, yplaque2 ,charge):
    x, y, z = position
    # Distribution de charge pour un condensateur avec des plaques parallèles chargées
    if y == yplaque1: # Plaque positive
        return charge
    elif y==yplaque2:
        return -charge
    else:
        return 0.0  # Aucune charge ailleurs 

# Position de la plaque chargée
yplaque1 = 2
yplaque2=12

# Calcul des coordonnées du maillage P qui respectent la condition sur y==yfixe et leur charge associée
coordonnees_maillage_P = [(i * h, y, k * h) for i in range(N) for k in range(N) for y in [yplaque1,yplaque2]]
charges_maillage_P = [distribution_doubleplaque(P, yplaque1, yplaque2, charge) for P in coordonnees_maillage_P]


# Calcul du champ électrique créé par la distribution des charges dans le maillage P partout dans le maillage M
champ_electrique_M = np.zeros((N, N, N, 3))

for i in range(N):
    for j in range(N):
        for k in range(N):
            E = np.zeros(3)
            for P, charge_at_point in zip(coordonnees_maillage_P, charges_maillage_P):
                PM = calcul_composantes_vect(maillage_M[i][j][k], P)
                norme_PM = calcul_norme_vect(PM)
                E += calcul_champ_electrique(epsilon, norme_PM, charge_at_point, PM)
            champ_electrique_M[i, j, k] = E

# Affichage des vecteurs du champ électrique
fig = plt.figure(figsize=(12, 9))
ax = fig.add_subplot(111, projection='3d')

for i in range(0, N, 2):
    for j in range(0, N, 2):
        for k in range(0, N, 2):
            ax.quiver(maillage_M[i][j][k][0], maillage_M[i][j][k][1], maillage_M[i][j][k][2],
                      champ_electrique_M[i, j, k][0],
                      champ_electrique_M[i, j, k][1],
                      champ_electrique_M[i, j, k][2],
                      length=1, normalize=True, color='blue')

ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('Z')
ax.set_title('Champ électrique crée par une plaque infinie')

plt.show()



################TEST 


for i in range (N):
    M_point=(10,i,10)
    position=(10,6,10)


    a=calcul_composantes_vect(M_point, position)
    

    b=calcul_norme_vect(a)
    

    c=calcul_potentiel(epsilon, b, charge_unitaire)

    d=calcul_champ_electrique(epsilon, b, charge, a)
    print(d)

fig = plt.figure(figsize=(12, 9))
ax = fig.add_subplot(111,)
ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_title('Champ électrique pour les P etudies')

plt.plot(x,y,z)


plt.show()








