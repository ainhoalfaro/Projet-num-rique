import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

def grad_space(h1, h2):
    # Générer le maillage de distribution avec un pas h1
    x1 = np.arange(-10, 10, h1)
    y1 = np.arange(-10, 10, h1)
    z1 = np.arange(-10, 10, h1)
    X1, Y1, Z1 = np.meshgrid(x1, y1, z1)

    # Générer le maillage de représentation avec un pas h2
    x2 = np.arange(-10, 10, h2)
    y2 = np.arange(-10, 10, h2)
    z2 = np.arange(-10, 10, h2)
    X2, Y2, Z2 = np.meshgrid(x2, y2, z2)

    # Afficher les maillages
    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')
    ax.scatter(X1, Y1, Z1, color='green', label=f'Maillage h1={h1}', s=10)  # Réduire la taille des points avec s=10
    ax.scatter(X2, Y2, Z2, color='blue', label=f'Maillage h2={h2}', s=10)   # Réduire la taille des points avec s=10
    ax.set_xlabel('X')
    ax.set_ylabel('Y')
    ax.set_zlabel('Z')
    ax.legend()
    plt.show()

# Test de la fonction
grad_space(1, 2)  # Test avec des pas h1=1 et h2=2




#version originale


import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

def grad_space(h1, h2):
    # Générer le maillage de distribution avec un pas h1
    x1 = np.arange(-10, 10, h1)
    y1 = np.arange(-10, 10, h1)
    z1 = np.arange(-10, 10, h1)
    X1, Y1, Z1 = np.meshgrid(x1, y1, z1)

    # Générer le maillage de représentation avec un pas h2
    x2 = np.arange(-10, 10, h2)
    y2 = np.arange(-10, 10, h2)
    z2 = np.arange(-10, 10, h2)
    X2, Y2, Z2 = np.meshgrid(x2, y2, z2)

    # Afficher les maillages
    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')
    ax.scatter(X1, Y1, Z1, color='green', label=f'Maillage h1={h1}')
    ax.scatter(X2, Y2, Z2, color='blue', label=f'Maillage h2={h2}')
    ax.set_xlabel('X')
    ax.set_ylabel('Y')
    ax.set_zlabel('Z')
    ax.legend()
    plt.show()

# Test de la fonction
grad_space(1, 2)  # Test avec des pas h1=1 et h2=2






#NIVEAU 3

def calcul_composantes_vect(M, P):
    # Calculer les composantes du vecteur PM
    PM = [M[i] - P[i] for i in range(3)]
    return PM

def calcul_norme_vect(PM):
    # Calculer la norme du vecteur PM
    norme_PM = np.linalg.norm(PM)
    return norme_PM

# Test des sous-fonctions
M = [3, 4, 5]
P = [1, 1, 1]
PM = calcul_composantes_vect(M, P)
norme_PM = calcul_norme_vect(PM)
print("Composantes de PM:", PM)
print("Norme de PM:", norme_PM)



#NIVEAU 2
def calcul_potentiel(epsilon, norme_PM, q):
    # Calcul de la norme de PM
    norme_PM = np.linalg.norm(norme_PM)
    
    # Calcul du potentiel électrique au point M dû à la charge q
    V = q / (4 * np.pi * epsilon * norme_PM)
    return V

# Test de la fonction
epsilon = 8.85e-12  # Constante électrique en F/m

q = 1e-9  # Valeur de la charge en C (exemple)
potentiel = calcul_potentiel(epsilon, norme_PM, q)
print("Potentiel électrique calculé au point M:", potentiel, "V")




def calcul_champ_electrique(PM, q):
    # Calcul des composantes de PM
    x_PM, y_PM, z_PM = PM
    
    # Calcul de la norme de PM
    norme_PM = calcul_norme_vect(PM)
    
    # Calcul des composantes du champ électrique
    Ex = q * x_PM / (4 * np.pi * epsilon * norme_PM ** 3)
    Ey = q * y_PM / (4 * np.pi * epsilon * norme_PM ** 3)
    Ez = q * z_PM / (4 * np.pi * epsilon * norme_PM ** 3)
    
    return [Ex, Ey, Ez]

# Test de la fonction
PM = [1, 2, 3]  # Vecteur PM (exemple)
q = 1e-9  # Valeur de la charge en C (exemple)
epsilon = 8.85e-12  # Constante électrique en F/m
composantes_E = calcul_champ_electrique(PM, q)
print("Composantes du champ électrique:", composantes_E)



#############################################################################

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

def maillage_M(h, N):
    maillage = []
    for i in range(N):
        maillage.append([])
        for j in range(N):
            maillage[i].append([])
            for k in range(N):
                maillage[i][j].append((i * h, j * h, k * h))
    return maillage

def calcul_composantes_vect(M_point, position):
    # Calculer les composantes du vecteur PM pour un point M donné
    PM = [M_point[i] - position[i] for i in range(3)]
    return PM

def calcul_norme_vect(PM):
    # Calculer la norme du vecteur PM
    somme = sum(comp ** 2 for comp in PM)
    norme_PM = np.sqrt(somme)
    return norme_PM

def calcul_potentiel(epsilon, norme_PM, charge):
    # Calcul du potentiel électrique 
    V = charge / (4 * np.pi * epsilon * norme_PM)
    return V

def calcul_champ_electrique(epsilon, norme_PM, charge, PM):
    # Calculer les composantes du champ électrique
    E_components = [(comp * charge / (norme_PM ** 3)) * (4 * np.pi * epsilon) for comp in PM]
    E = np.array(E_components)
    return E

def calcul_charge(position):
    x, y, z = position
    # Distribution de charge pour un condensateur avec des plaques parallèles chargées
    if 2 <= x <= 8 and 4 <= y <= 6:  # Plaque positive
        return 1.0
    elif 2 <= x <= 8 and 14 <= y <= 16:  # Plaque négative
        return -1.0
    else:
        return 0.0  # Aucune charge ailleurs

P_position = [0, 0, 0]

epsilon = 1 / (4 * np.pi)

N = 20
h = 1
M = maillage_M(h, N)

# Calculer le potentiel électrique et le champ électrique pour chaque point du maillage
potentiel_values = np.zeros((N, N, N))
champ_electrique_values = np.zeros((N, N, N, 3))

for i in range(N):
    for j in range(N):
        for k in range(N):
            PM = calcul_composantes_vect(M[i][j][k], P_position)
            norme_PM = calcul_norme_vect(PM)
            charge_at_point = calcul_charge(M[i][j][k])
            potentiel_values[i, j, k] = calcul_potentiel(epsilon, norme_PM, charge_at_point)
            champ_electrique_values[i, j, k] = calcul_champ_electrique(epsilon, norme_PM, charge_at_point, PM)

# Affichage des vecteurs du champ électrique
fig = plt.figure(figsize=(12, 9))
ax = fig.add_subplot(111, projection='3d')

for i in range(0, N, 2):
    for j in range(0, N, 2):
        for k in range(0, N, 2):
            ax.quiver(M[i][j][k][0], M[i][j][k][1], M[i][j][k][2],
                      champ_electrique_values[i, j, k][0],
                      champ_electrique_values[i, j, k][1],
                      champ_electrique_values[i, j, k][2],
                      length=1, normalize=True, color='blue')

ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('Z')
ax.set_title('Champ électrique d\'un condensateur avec distribution de charge')

plt.show()




###########################################################
TEST DU PROGRAMME

for i in range (N):
    M_point=(10,i,10)
    position=(10,6,10)


    a=calcul_composantes_vect(M_point, position)
    

    b=calcul_norme_vect(a)
    

    c=calcul_potentiel(epsilon, b, charge)

    d=calcul_champ_electrique(epsilon, b, charge, a)
    print(d)
















######################################################## plque NON infinie


import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

def maillage(h, N):
    maillage = []
    for i in range(N):
        maillage.append([])
        for j in range(N):
            maillage[i].append([])
            for k in range(N):
                maillage[i][j].append((i * h, j * h, k * h))
    return maillage

def calcul_composantes_vect(M_point, position):
    # Calculer les composantes du vecteur PM pour un point M donné
    PM = np.array(M_point) - np.array(position)
    return PM

def calcul_norme_vect(PM):
    # Calculer la norme du vecteur PM
    norme_PM = np.linalg.norm(PM)
    return norme_PM

def calcul_potentiel(epsilon, norme_PM, charge):
    # Calcul du potentiel électrique 
    V = charge / (4 * np.pi * epsilon * norme_PM)
    return V

def calcul_champ_electrique(epsilon, norme_PM, charge, PM):
    # Calculer les composantes du champ électrique
    E = (charge * PM) / (4 * np.pi * epsilon * (norme_PM ** 3))
    return E

def distribution_plaqueinfinie(position, y):
    x, ypos, z = position
    # Distribution de charge pour un condensateur avec des plaques parallèles chargées
    if ypos == yfixe: # Plaque positive
        return 1.0
    else:
        return 0.0  # Aucune charge ailleurs 
    

#def distribution_plaqueinfinie(position, yplaque):
    try:
        x, ypos, z = position  # Expecting a tuple with three elements
    except ValueError:
        print("Error unpacking position:", position)  # This will show what's wrong
        raise  # Re-raise the exception to stop execution and signal the error

    if ypos == yplaque:
        return 1.0  # Plaque positive
    else:
        return 0.0  # Aucune charge ailleurs




# Paramètres
epsilon = 8.85e-12  # Constante diélectrique du vide
yfixe = 0.0  # Position y de la plaque chargée

N = 20  # Maillage de dimension 20x20x20, ce qui signifie que votre espace est divisé en 20 intervalles le long de chaque axe (x, y, z), et chaque intervalle a une taille de 1 unité dans chaque direction.
h = 1.0

# Génération des maillages
maillage_M = maillage(h, N)
maillage_P = maillage(h, N)

# Position de la plaque chargée
yplaque = 6

# Calcul du champ électrique créé par la distribution d'une plaque infinie dans le maillage P partout dans le maillage M
#champ_electrique_M = np.zeros((N, N, N, 3))

for M in maillage_M:
    E = np.zeros((N, N, 3))
    for P in maillage_P:
        print(P)
        PM = calcul_composantes_vect(M, (0, yplaque, 0))
        norme_PM = calcul_norme_vect(PM)
        for x in range(20):
            for y in range(20):
                charge_at_point = distribution_plaqueinfinie(P[x][y], yplaque)
        print(calcul_champ_electrique(epsilon, norme_PM, charge_at_point, PM))    
        E += calcul_champ_electrique(epsilon, norme_PM, charge_at_point, PM)
   # champ_electrique_M[i, j, k] = E

# Affichage des vecteurs du champ électrique
fig = plt.figure(figsize=(12, 9))
ax = fig.add_subplot(111, projection='3d')

for i in range(0, N, 2):
    for j in range(0, N, 2):
        for k in range(0, N, 2):
            ax.quiver(maillage_M[i][j][k][0], maillage_M[i][j][k][1], maillage_M[i][j][k][2],
                      champ_electrique_M[i, j, k][0],
                      champ_electrique_M[i, j, k][1],
                      champ_electrique_M[i, j, k][2],
                      length=1, normalize=True, color='blue')

ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('Z')
ax.set_title('Champ électrique d\'un condensateur avec distribution de charge')

plt.show()










########################### VERSION PLAQUE NON INFINIE 2
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

def maillage(h, N):
    maillage = []
    for i in range(N):
        maillage.append([])
        for j in range(N):
            maillage[i].append([])
            for k in range(N):
                maillage[i][j].append((i * h, j * h, k * h))
    return maillage


def calcul_composantes_vect(M_point, position):
    # Calculer les composantes du vecteur PM pour un point M donné
    PM = [M_point[i] - position[i] for i in range(3)]
    return PM

def calcul_norme_vect(PM):
    # calculer la norme du vecteur PM
    somme = sum(comp ** 2 for comp in PM)
    norme_PM = np.sqrt(somme)
    return norme_PM

def calcul_potentiel(epsilon, norme_PM, charge):
    # Calcul du potentiel électrique 
    V = charge / (4 * np.pi * epsilon * norme_PM)
    return V

def calcul_champ_electrique(epsilon, norme_PM, charge, PM):
    # Calculer les composantes du champ électrique
    E_components = [(comp * charge / (norme_PM ** 3)) * (4 * np.pi * epsilon) for comp in PM]
    E = np.array(E_components)
    return E

def calcul_composantes_vect(M_point, position):
    # Calculer les composantes du vecteur PM pour un point M donné
    PM = np.array(M_point) - np.array(position)
    return PM

def distribution_plaqueinfinie(position, y, charge_unitaire):
    x, y, z = position
    # Distribution de charge pour un condensateur avec des plaques parallèles chargées
    if y == yfixe: # Plaque positive
        return charge_unitaire
    else:
        return 0.0  # Aucune charge ailleurs 

# Paramètres
epsilon = 8.85e-12  # Constante diélectrique du vide
yfixe = 6 # Position y de la plaque chargée
charge_unitaire = 1.0  # Charge élémentaire

N = 20  # Maillage de dimension 20x20x20, ce qui signifie que votre espace est divisé en 20 intervalles le long de chaque axe (x, y, z), et chaque intervalle a une taille de 1 unité dans chaque direction.
h = 1.0

# Génération des maillages
maillage_M = maillage(h, N)
maillage_P = maillage(h, N)

# Position de la plaque chargée
yplaque = 6

# Calcul des coordonnées du maillage P qui respectent la condition sur y==yfixe et leur charge associée
coordonnees_maillage_P = [(i * h, yplaque, k * h) for i in range(N) for k in range(N)]
charges_maillage_P = [distribution_plaqueinfinie(P, yplaque, charge_unitaire) for P in coordonnees_maillage_P]

# Calcul du champ électrique créé par la distribution des charges dans le maillage P partout dans le maillage M
champ_electrique_M = np.zeros((N, N, N, 3))

for i in range(N):
    for j in range(N):
        for k in range(N):
            E = np.zeros(3)
            for P, charge_at_point in zip(coordonnees_maillage_P, charges_maillage_P):
                PM = calcul_composantes_vect(maillage_M[i][j][k], P)
                norme_PM = calcul_norme_vect(PM)
                E += calcul_champ_electrique(epsilon, norme_PM, charge_at_point, PM)
            champ_electrique_M[i, j, k] = E

# Affichage des vecteurs du champ électrique
fig = plt.figure(figsize=(12, 9))
ax = fig.add_subplot(111, projection='3d')

for i in range(0, N, 2):
    for j in range(0, N, 2):
        for k in range(0, N, 2):
            ax.quiver(maillage_M[i][j][k][0], maillage_M[i][j][k][1], maillage_M[i][j][k][2],
                      champ_electrique_M[i, j, k][0],
                      champ_electrique_M[i, j, k][1],
                      champ_electrique_M[i, j, k][2],
                      length=1, normalize=True, color='blue')

ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('Z')
ax.set_title('Champ électrique crée par une plaque infinie')

plt.show()

